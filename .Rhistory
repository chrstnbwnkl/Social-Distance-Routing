install.packages('DBI')
install.packages("DBI")
# Connect to the default postgres database
con <- dbConnect(RPostgres::Postgres(),dbname = 'M6',
host = 'localhost',
port = 5432, # or any other port specified by your DBA
user = 'postgres',
password = 'wasser')
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
install.packages(dplyr)
install.packages("dplyr")
as_Spatial(data)
as_Spatial(grd_sf)
require("RPostgres")
require('automap')
require('sf')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
as_Spatial(grd_sf)
# Connect to the default postgres database
con <- dbConnect(RPostgres::Postgres(),dbname = 'M6',
host = 'localhost',
port = 5432, # or any other port specified by your DBA
user = 'postgres',
password = 'wasser')
res <- dbSendQuery(con, "SELECT total_of_directions AS z, ST_X(geom) AS lon, ST_Y(geom) AS lat, sensor_id AS id FROM ped_count WHERE total_of_directions IS NOT NULL ORDER BY sensor_id")
data <- dbFetch(res)
p.sf <- st_as_sf(data, coords = c("lon", "lat"), crs = 4326)
grid_lat <- seq(-37.8328849, -37.7930220, 0.001)
grid_lon <- seq(144.9341885, 144.9877509, 0.001)
grd <- expand.grid(lon = grid_lon, lat = grid_lat)
grd_sf  <-  st_as_sf(grd, coords = c("lon", "lat"),
crs = 4326, agr = "constant")
grd_sp <- as_Spatial(grd_sf)
count_data = as(p.sf, "Spatial")
count_data_transform <- spTransform(count_data, crs("+init=epsg:3857"))
grid_3857 <- spTransform(grd_sp, crs("+init=epsg:3857"))
krigingResult <- autoKrige(formula=z~1, input_data=count_data_transform, new_data = grid_3857)
resultSP_4326 <- spTransform(krigingResult$krige_output, crs("+init=epsg:4326"))
resultRaster <- rasterFromXYZ(resultSP_4326, crs=crs("+init=epsg:4326"))
writeRaster(resultRaster, filename="rraster.asc", format="ascii", overwrite=TRUE)
filename <- "rraster.asc"
cmds <- paste("raster2pgsql -d -s 4326 -I -F -t 50x50",filename,"rraster |psql -U postgres -d M6 -h localhost -p 5432", sep=" ")
shell(cmds)
as_Spatial(data)
data[,c(1,2)]
data[,c(2,3)]
xy <- data[,c(2,3)]
View(xy)
spdf <- SpatialPointsDataFrame(coords = xy, data = data,
proj4string = CRS("+init=epsg:4326"))
spdf
View(grd)
grd_spdf <- SpatialPointsDataFrame(coords = grd,
proj4string = CRS("+init=epsg:4326"))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=NULL
proj4string = CRS("+init=epsg:4326"))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=FALSE
proj4string = CRS("+init=epsg:4326"))
df <- data.frame()
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df
proj4string = CRS("+init=epsg:4326"))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df,
proj4string = CRS("+init=epsg:4326"))
grd_sp
df <- data.frame(matrix(NA, nrow = 59, ncol = 1))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df,
proj4string = CRS("+init=epsg:4326"))
df <- data.frame(matrix(NA, nrow = 2160, ncol = 1))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df,
proj4string = CRS("+init=epsg:4326"))
require("RPostgres")
require('automap')
require('sf')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
# Connect to the default postgres database
con <- dbConnect(RPostgres::Postgres(),dbname = 'M6',
host = 'localhost',
port = 5432, # or any other port specified by your DBA
user = 'postgres',
password = 'wasser')
res <- dbSendQuery(con, "SELECT total_of_directions AS z, ST_X(geom) AS lon, ST_Y(geom) AS lat, sensor_id AS id FROM ped_count WHERE total_of_directions IS NOT NULL ORDER BY sensor_id")
data <- dbFetch(res)
grid_lat <- seq(-37.8328849, -37.7930220, 0.001)
grid_lon <- seq(144.9341885, 144.9877509, 0.001)
grd <- expand.grid(lon = grid_lon, lat = grid_lat)
df <- data.frame(matrix(NA, nrow = 2160, ncol = 1))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df, proj4string = CRS("+init=epsg:4326"))
#grd_sf  <-  st_as_sf(grd, coords = c("lon", "lat"),
#                    crs = 4326, agr = "constant")
#grd_sp <- as_Spatial(grd_sf)
xy <- data[,c(2,3)]
spdf <- SpatialPointsDataFrame(coords = xy, data = data,
proj4string = CRS("+init=epsg:4326"))
count_data_transform <- spTransform(spdf, crs("+init=epsg:3857"))
grid_3857 <- spTransform(grd_spdf, crs("+init=epsg:3857"))
krigingResult <- autoKrige(formula=z~1, input_data=count_data_transform, new_data = grid_3857)
resultSP_4326 <- spTransform(krigingResult$krige_output, crs("+init=epsg:4326"))
resultRaster <- rasterFromXYZ(resultSP_4326, crs=crs("+init=epsg:4326"))
writeRaster(resultRaster, filename="rraster.asc", format="ascii", overwrite=TRUE)
filename <- "rraster.asc"
cmds <- paste("raster2pgsql -d -s 4326 -I -F -t 50x50",filename,"rraster |psql -U postgres -d M6 -h localhost -p 5432", sep=" ")
shell(cmds)
require("RPostgres")
require('automap')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
# Connect to the default postgres database
con <- dbConnect(RPostgres::Postgres(),dbname = 'M6',
host = 'localhost',
port = 5432, # or any other port specified by your DBA
user = 'postgres',
password = 'wasser')
res <- dbSendQuery(con, "SELECT total_of_directions AS z, ST_X(geom) AS lon, ST_Y(geom) AS lat, sensor_id AS id FROM ped_count WHERE total_of_directions IS NOT NULL ORDER BY sensor_id")
data <- dbFetch(res)
grid_lat <- seq(-37.8328849, -37.7930220, 0.001)
grid_lon <- seq(144.9341885, 144.9877509, 0.001)
grd <- expand.grid(lon = grid_lon, lat = grid_lat)
df <- data.frame(matrix(NA, nrow = 2160, ncol = 1))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df, proj4string = CRS("+init=epsg:4326"))
#grd_sf  <-  st_as_sf(grd, coords = c("lon", "lat"),
#                    crs = 4326, agr = "constant")
#grd_sp <- as_Spatial(grd_sf)
xy <- data[,c(2,3)]
spdf <- SpatialPointsDataFrame(coords = xy, data = data,
proj4string = CRS("+init=epsg:4326"))
count_data_transform <- spTransform(spdf, crs("+init=epsg:3857"))
grid_3857 <- spTransform(grd_spdf, crs("+init=epsg:3857"))
krigingResult <- autoKrige(formula=z~1, input_data=count_data_transform, new_data = grid_3857)
resultSP_4326 <- spTransform(krigingResult$krige_output, crs("+init=epsg:4326"))
resultRaster <- rasterFromXYZ(resultSP_4326, crs=crs("+init=epsg:4326"))
writeRaster(resultRaster, filename="rraster.asc", format="ascii", overwrite=TRUE)
filename <- "rraster.asc"
cmds <- paste("raster2pgsql -d -s 4326 -I -F -t 50x50",filename,"rraster |psql -U postgres -d M6 -h localhost -p 5432", sep=" ")
shell(cmds)
resultSP_4326
resultSP_4326[var1.pred]
resultSP_4326[,c(1,2)]
resultRaster
shape <- readOGR(dsn = ".", layer = "pixel_dump")
require("RPostgres")
require('automap')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
shape <- readOGR(dsn = ".", layer = "pixel_dump")
shape <- readOGR(dsn = "C:\Users\Chris\Documents\GIMA\Module 6\software-testing", layer = "pixel_dump")
shape <- readOGR(dsn = "C:/Users/Chris/Documents/GIMA/Module 6/software-testing", layer = "pixel_dump")
class(shape)
for (i in seq_along(shape)) {
shape[[i]]@data = cbind(shape[[i]]@data, unique.id = i)
}
for (i in seq_along(shape)) {
shape[[i]]$unique.id <- i
}
for (i in seq_along(shape)-1) {
shape[[i]]$unique.id <- i
}
for (i in (seq_along(shape))-1 {
shape[[i]]$unique.id <- i
}
shape <- readOGR(dsn = "C:/Users/Chris/Documents/GIMA/Module 6/software-testing", layer = "pixel_dump")
shape
shape[,c(2)
]
shape[,c(2)]
shape@data
shape@data$ID
shape@data$ID <- as.numeric(shape@data$ID)
shape
install.packages("RPostgreSQL")
install.packages('RPostgreSQL')
require("RPostgreSQL")
require('automap')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
conn <- RPostgreSQL::dbConnect("PostgreSQL", host = "localhost",
dbname = "M6", user = "postgres", password = "wasser")
shape <- readOGR(dsn = ".", layer = "pixel_dump")
shape@data$ID <- as.numeric(shape@data$ID)
shape <- readOGR(dsn = "./GIMA/Module 6/software-testing", layer = "pixel_dump")
shape@data$ID <- as.numeric(shape@data$ID)
pgPostGIS(conn)
require("RPostgreSQL")
pgPostGIS(conn)
require('rpostgis')
install.packages('rpostgis')
require('rpostgis')
pgPostGIS(conn)
plot(shape)
res <- dbSendQuery(con, "SELECT total_of_directions AS z, ST_X(geom) AS lon, ST_Y(geom) AS lat, sensor_id AS id FROM ped_count WHERE total_of_directions IS NOT NULL ORDER BY sensor_id")
data <- dbFetch(res)
res <- dbSendQuery(con, "SELECT total_of_directions AS z, ST_X(geom) AS lon, ST_Y(geom) AS lat, sensor_id AS id FROM ped_count WHERE total_of_directions IS NOT NULL ORDER BY sensor_id")
res <- dbSendQuery(conn, "SELECT total_of_directions AS z, ST_X(geom) AS lon, ST_Y(geom) AS lat, sensor_id AS id FROM ped_count WHERE total_of_directions IS NOT NULL ORDER BY sensor_id")
data <- dbFetch(res)
data
grid_lat <- seq(-37.8328849, -37.7930220, 0.001)
grid_lon <- seq(144.9341885, 144.9877509, 0.001)
grd <- expand.grid(lon = grid_lon, lat = grid_lat)
df <- data.frame(matrix(NA, nrow = 2160, ncol = 1))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df, proj4string = CRS("+init=epsg:4326"))
xy <- data[,c(2,3)]
spdf <- SpatialPointsDataFrame(coords = xy, data = data,
proj4string = CRS("+init=epsg:4326"))
count_data_transform <- spTransform(spdf, crs("+init=epsg:3857"))
grid_3857 <- spTransform(grd_spdf, crs("+init=epsg:3857"))
krigingResult <- autoKrige(formula=z~1, input_data=count_data_transform, new_data = grid_3857)
resultSP_4326 <- spTransform(krigingResult$krige_output, crs("+init=epsg:4326"))
View(resultSP_4326)
over(shape, resultSP_4326[,"var1.pred"])
shape.data <-over(shape, resultSP_4326[,"var1.pred"])
A$ped_count <- shape.data$var1.pred
shape$ped_count <- shape.data$var1.pred
shape
over(shape, resultSP_4326[,"var1.pred"])
pgInsert(conn, c("public", "krigeGrid"), shape)
require("RPostgreSQL")
require('rpostgis')
require('automap')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
# Establish Postgres connection
conn <- RPostgreSQL::dbConnect("PostgreSQL", host = "localhost",
dbname = "M6", user = "postgres", password = "wasser")
# Load pixel dump for pre-processing
shape <- readOGR(dsn = "./GIMA/Module 6/software-testing", layer = "pixel_dump")
shape@data$ID <- as.numeric(shape@data$ID)
# Fetch pedestrian count data
res <- dbSendQuery(conn, "SELECT total_of_directions AS z, ST_X(geom) AS lon, ST_Y(geom) AS lat, sensor_id AS id FROM ped_count WHERE total_of_directions IS NOT NULL ORDER BY sensor_id")
data <- dbFetch(res)
# Compute grid for prediction
grid_lat <- seq(-37.8328849, -37.7930220, 0.001)
grid_lon <- seq(144.9341885, 144.9877509, 0.001)
grd <- expand.grid(lon = grid_lon, lat = grid_lat)
df <- data.frame(matrix(NA, nrow = 2160, ncol = 1))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df, proj4string = CRS("+init=epsg:4326"))
# Pedestrian count data to spatial object (includes transformation to xy for kriging, then back to lat/lon for web mapping)
xy <- data[,c(2,3)]
spdf <- SpatialPointsDataFrame(coords = xy, data = data,
proj4string = CRS("+init=epsg:4326"))
count_data_transform <- spTransform(spdf, crs("+init=epsg:3857"))
grid_3857 <- spTransform(grd_spdf, crs("+init=epsg:3857"))
# Kriging w/ autofitting
krigingResult <- autoKrige(formula=z~1, input_data=count_data_transform, new_data = grid_3857)
resultSP_4326 <- spTransform(krigingResult$krige_output, crs("+init=epsg:4326"))
# Store predicted value in polygons
shape.data <- over(shape, resultSP_4326[,"var1.pred"])
shape$ped_count <- shape.data$var1.pred
# Insert results back into Postgres
pgInsert(conn, c("public", "krigeGrid"), shape)
require("RPostgreSQL")
require('rpostgis')
require('automap')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
# Establish Postgres connection
conn <- RPostgreSQL::dbConnect("PostgreSQL", host = "localhost",
dbname = "M6", user = "postgres", password = "wasser")
# Load pixel dump for pre-processing
shape <- readOGR(dsn = "./GIMA/Module 6/software-testing", layer = "pixel_dump")
shape@data$ID <- as.numeric(shape@data$ID)
# Fetch pedestrian count data
res <- dbSendQuery(conn, "SELECT total_of_directions AS z, ST_X(geom) AS lon, ST_Y(geom) AS lat, sensor_id AS id FROM ped_count WHERE total_of_directions IS NOT NULL ORDER BY sensor_id")
data <- dbFetch(res)
# Compute grid for prediction
grid_lat <- seq(-37.8328849, -37.7930220, 0.001)
grid_lon <- seq(144.9341885, 144.9877509, 0.001)
grd <- expand.grid(lon = grid_lon, lat = grid_lat)
df <- data.frame(matrix(NA, nrow = 2160, ncol = 1))
grd_spdf <- SpatialPointsDataFrame(coords = grd, data=df, proj4string = CRS("+init=epsg:4326"))
# Pedestrian count data to spatial object (includes transformation to xy for kriging, then back to lat/lon for web mapping)
xy <- data[,c(2,3)]
spdf <- SpatialPointsDataFrame(coords = xy, data = data,
proj4string = CRS("+init=epsg:4326"))
count_data_transform <- spTransform(spdf, crs("+init=epsg:3857"))
grid_3857 <- spTransform(grd_spdf, crs("+init=epsg:3857"))
# Kriging w/ autofitting
krigingResult <- autoKrige(formula=z~1, input_data=count_data_transform, new_data = grid_3857)
resultSP_4326 <- spTransform(krigingResult$krige_output, crs("+init=epsg:4326"))
# Store predicted value in polygons
shape.data <- over(shape, resultSP_4326[,"var1.pred"])
shape$ped_count <- shape.data$var1.pred
# Insert results back into Postgres
pgInsert(conn, c("public", "krigeGrid"), shape)
# Update cost layer
dbSendQuery(conn, 'UPDATE mb_ex_2po_4pgr SET new_cost = final_intersect.ped_count_total/cast(final_intersect.counts as decimal)/st_length(geom_way)
FROM (
SELECT network.id, SUM(ped_count) as ped_count_total, COUNT(ped_count) as counts FROM mb_ex_2po_4pgr AS network
INNER JOIN krige_intersect ON krige_intersect.edge_id = network.id
INNER JOIN public."krigeGrid" ON public."krigeGrid"."ID" = krige_intersect.grid_id
GROUP BY network.id
) as final_intersect;')
install.packages("dotenv")
require("RPostgreSQL")
require('rpostgis')
require('automap')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
library(dotenv)
load_dot_env(tmp)Sys.getenv(".env")
require("RPostgreSQL")
require('rpostgis')
require('automap')
require('sp')
library(DBI)
library(rgdal)
library(raster)
library(rgeos)
library(dotenv)
load_dot_env(".env")
Sys.getenv(".env")
load_dot_env("")
load_dot_env()
getwd()
setwd("//GIMA//Module 6//")
setwd("/GIMA/Module 6/")
setwd(choose.dir())
getwd
getwd()
load_dot_env()
Sys.getenv("password")
